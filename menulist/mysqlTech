DB技术本质：在一致性的基础上(事务、断电、并发、因为缓存造成的不一致),通过算法(大数据量写入、搜索)、内存、硬件(顺序独写)加速。充分利用硬件的能力

问题：矛盾点：
				1.可重复读隔离级别，事务 T 启 动的时候会创建一个视图 read-view，之后事务 T 执行期间，即使有其他事务修改了数 据，事务 T 看到的仍然跟在启动时看到的一样
				2.一个事务要更新一行，如果刚好有 另外一个事务拥有这一行的行锁，它又不能这么超然了，会被锁住，进入等待状态。
				
				begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用 start	transaction with consistent snapshot 这个命令。

				是默认 autocommit=1。


			  读锁？写锁？两个update事务时等待，一个读一个写则遵循1

		事务和锁关系：
				1.两个视图
					1.它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结 果。创建视图的语法是 create view … ，而它的查询方法与表一样。
					2.InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，用 于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离 级别的实现
						
						1.基于整库---InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒 级创建快照”的能力。
									1.每个事务有一个唯一transaction id,递增申请。和每行变化的事务id进行比对，判断是否要找‘上一个’版本
									2.每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本， 并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。 。。excel:行+列(rowid)
									3.同时，旧的数据 版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。只记录update的版本和undolog而不是所有的事务操作都记录
										单向链表定位 <--- undoLog实现 V1、V2、V3 并不是物理上真实存 在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。
						2.如何定义快照
									1.一个事务启动的时候，能够看到所有已经提交的事务结果。但是之 后，这个事务执行期间，其他事务的更新对它不可见 。 如果“上一个版本”也不可见，那就得继续往前找。 
									2.如果是这个事务自己更新 的数据，它自己还是要认的。
									3. InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正 在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。
										a. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；
									    b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。 ？？？ 

						3.读写关系
									1.读默认不加锁  所以当前镜像  如果加了了读锁（S 锁，共享锁）和写锁（X 锁，排他锁）。
 lock in share mode  / for update  则会读取最新事务提交的数据

 									2.对于update默认先读后写，读：当前读，读最新数据			<-- 类似 读提交
 									3.如果update操作时，有其他事务未提交改行锁，造成锁等待


 						4.对于可重复读，查询只承认在事务启动前就已经提交完成的数据；
						  对于读提交，查询只承认在语句启动前就已经提交完成的数据；
						  对于当前读，查询该行数据最新版本数据；

		普通索引 vs 唯一索引

				1.id_card是否做主键
					1.不建议，因为id_card较长，主键作为其他索引的引用，消耗太大了
					2.解决方案：倒排id_card  reverse(id_card)并使用前缀   ， 注意索引不是一定能唯一定位到一行(唯一索引)，对于普通索引只能定位范围，在轮询查找对比判断

				2.普通索引 vs 唯一索引 性能对比
						1.查询
								1.对于普通索引来说，查找到满足条件的第一个记录 (5,500) 后，需要查找下一个记录，直 到碰到第一个不满足 k=5 条件的记录。
								2.对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止 继续检索。
								==> 差距不大
								虽然存在db读取页的形式，多一次查询可能正好跨页导致加载，但每页近千个key,所以出现这种概率低
						2.更新	
								1.如果数据在内存中，则直接更新
								2.这个数据页还没有在内 存中的话，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了
								3.定期 merge。在数据库正常关闭 （shutdown）的过程中，也会执行 merge 操作 <-- hook


								唯一索引：判断是否违反唯一性约束，所以使用了内存，不使用change buffer 
								普通索引：change buffer 用的是 buffer pool 里的内存，因此不能无限增大。change buffer 的大 小，可以通过参数 innodb_change_buffer_max_size 来动态设置。这个参数设置为 50 的 时候，表示 	change buffer 的大小最多只能占用 buffer pool 的 50%。

				3.是否所有的普通索引都走change buffer呢？ -- 适用场景
							no 
								1.对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。
								2.一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新 先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。 这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代

				4.索引选择和实践
						1.在不使用db唯一约束情况下，优先使用普通索引，更好的update性能
						2.普通索引和 change buffer 的配合使用，对于数据量大的表的 更新优化还是很明显的。
						3.在使用机械硬盘时，change buffer 这个机制的收效是非常显著的。
						4.“历史数据”的库，
						5.归档数据已经是确保没有唯一键冲突 了

				5.change buffer 和 redo log
						1. Page 1 在内存中，直接更新内存； 
						2. Page 2 没有在内存中，就在内存的 change buffer 区域，记录下“我要往 Page 2 插入 一行”这个信息 
						3. 将上述两个动作记入 redo log 中（图中 3 和 4）。

					二者不同：二者维度不同，redolog是为了记录所有操作过程，不管是否读取磁盘。
							 change buffer
							 做完上面这些，事务就可以完成了。所以，你会看到，执行这条更新语句的成本很低，就是 写了两处内存，然后写了一处磁盘（两次操作合在一起写了一次磁盘），而且还是顺序写 的。

				6.有了change buffer如何保证一致性呢？
						1. 读 Page 1 的时候，直接从内存返回。有几位同学在前面文章的评论中问到，WAL 之后 如果读数据，是不是一定要读盘，是不是一定要从 redo log 里面把数据更新以后才可以 返回？其实是不用的。你可以看一下图 3 的这个状态，虽然磁盘上还是之前的数据，但 是这里直接从内存返回结果，结果是正确的。
						
						2. 要读 Page 2 的时候，需要把 Page 2 从磁盘读入内存中，然后应用 change buffer 里 面的操作日志，生成一个正确的版本并返回结果。可以看到，直到需要读 Page 2 的时候，这个数据页才会被读入内存。
						
				所以，如果要简单地对比这两个机制在提升更新性能上的收益的话，redo log 主要节省的 是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘 的 IO 消耗。


				问题：如果断电丢失change buffer ,如何保证一致性？
						会导致change buffer丢失，会导致本次未完成的操作数据丢失，但不会导致已完成操作的 数据丢失。 1.change buffer中分两部分，一部分是本次写入未写完的，一部分是已经写入完成的。 2.针对未写完的，此部分操作，还未写入redo log，因此事务还未提交，所以没影响。 2.针对，已经写完成的，可以通过redo log来进行恢复。 … 

						1、changebuffer跟普通数据页一样也是存在磁盘里，区别在于changebuffer是在共享表 空间ibdata1里 2、redolog有两种，一种记录普通数据页的改动，一种记录changebuffer的改动 
						3、只要内存里脏页（innodb buffer pool）里的数据发生了变化，就一定会记录2中前

				问题：有点疑惑: 主键id也是唯一索引吧? 那我们的新增操作如何利用 change buffer呢?
							作者回复: 所以主键索引用不上，都是对于那些二级索引的才有效。  
	 
							一个insert语句要操作所有索引的嘛，收益在二级索引

							insert的时候，写主键是肯定不能用change buffer了，但是同时也会要写其它索引，而其它索引 中的“非唯一索引”是可以用的这个机制的； 



